{
  "tasks": [
    {
      "id": 1,
      "title": "Implement RuleEngine Basics",
      "description": "Develop the fundamental event-condition-action processing loop within RuleEngine for basic game logic",
      "status": "done",
      "dependencies": [],
      "priority": "high",
      "details": "Create the RuleEngine class with methods for registering rules, processing events, and triggering actions. Implement the core event->condition->action processing loop that evaluates conditions and executes corresponding actions. Include methods for adding/removing rules dynamically. Rules should support basic game logic like scoring adjustments triggered by events. Ensure the RuleEngine properly interfaces with the EventBus to listen for relevant game events and emit action events when rules are triggered.",
      "testStrategy": "Create unit tests for rule registration, condition evaluation, and action execution. Test with mock events to verify correct rule triggering. Validate integration with EventBus by testing complete event->rule->action flows.",
      "subtasks": [
        {
          "id": 1,
          "title": "Define RuleEngine class structure and interfaces",
          "description": "Create the basic structure of the RuleEngine class with interfaces for Rule, Condition, and Action components",
          "dependencies": [],
          "details": "1. Create a Rule interface/class with properties for conditions and actions\n2. Define a Condition interface that evaluates game state and returns boolean\n3. Define an Action interface that executes changes to game state\n4. Create the RuleEngine class with storage for rules collection\n5. Add methods for rule registration (addRule) and removal (removeRule)\n6. Test by creating simple rule instances and verifying they can be added/removed from the engine",
          "status": "done",
          "parentTaskId": 1
        },
        {
          "id": 2,
          "title": "Implement event processing and condition evaluation",
          "description": "Develop the core mechanism to process incoming events and evaluate rule conditions",
          "dependencies": [
            1
          ],
          "details": "1. Add an event processing method (processEvent) that takes an event as input\n2. Implement logic to iterate through all registered rules\n3. For each rule, evaluate its condition against the current event and game state\n4. Create a filtering mechanism to quickly identify rules relevant to specific event types\n5. Add logging for condition evaluation results\n6. Test by creating mock events and conditions, verifying conditions evaluate correctly",
          "status": "done",
          "parentTaskId": 1
        },
        {
          "id": 3,
          "title": "Implement action execution mechanism",
          "description": "Create the system to execute actions when conditions are met",
          "dependencies": [
            2
          ],
          "details": "1. Extend the processEvent method to execute actions when conditions evaluate to true\n2. Implement action execution that can modify game state\n3. Add support for multiple actions per rule\n4. Implement error handling for action execution\n5. Add logging for action execution\n6. Test by creating rules with mock conditions (always true) and verifying actions execute properly",
          "status": "done",
          "parentTaskId": 1
        },
        {
          "id": 4,
          "title": "Integrate RuleEngine with EventBus",
          "description": "Connect the RuleEngine to the EventBus to listen for game events and emit action events",
          "dependencies": [
            3
          ],
          "details": "1. Add EventBus dependency to RuleEngine\n2. Implement event subscription method to register for relevant game events\n3. Update processEvent to handle EventBus event format\n4. Add method to emit action events back to the EventBus\n5. Implement initialization logic to subscribe to events when RuleEngine starts\n6. Test by verifying RuleEngine properly receives events from EventBus and emits action events",
          "status": "done",
          "parentTaskId": 1
        },
        {
          "id": 5,
          "title": "Implement basic game logic rules",
          "description": "Create sample rules for common game logic scenarios like scoring and state changes",
          "dependencies": [
            4
          ],
          "details": "1. Implement a ScoreRule class that extends Rule for point-based scoring\n2. Create a StateChangeRule class for game state transitions\n3. Add factory methods to RuleEngine for creating common rule types\n4. Implement rule prioritization to control execution order\n5. Add rule categories/tags for organization\n6. Test with integration tests that verify complete event-condition-action flow with realistic game scenarios (e.g., player collects item → condition checks item type → action awards appropriate points)",
          "status": "done",
          "parentTaskId": 1
        }
      ]
    },
    {
      "id": 2,
      "title": "Develop AudioManager with Basic Functionality",
      "description": "Implement a basic AudioManager using Howler.js for sound effects and music in the game",
      "status": "done",
      "dependencies": [
        1
      ],
      "priority": "high",
      "details": "Create the AudioManager class that integrates with PixiEngine. Use Howler.js for audio handling. Implement core methods: registerSound, play, stop, setVolume, and mute/unmute. Configure the manager to load default sounds from '/public/audio/default/' (correct.mp3, incorrect.mp3, etc.). Add event listeners to connect with RuleEngine for automatic sound triggering on game events. Ensure proper resource management (loading/unloading sounds) and error handling for missing audio files.",
      "testStrategy": "Test sound registration, playback, and volume controls. Verify integration with RuleEngine by triggering game events and confirming appropriate sounds play. Test error handling with missing audio files and edge cases."
    },
    {
      "id": 3,
      "title": "Refine ControlsManager for Unified Input Handling",
      "description": "Enhance the ControlsManager to handle keyboard, mouse, and touch inputs with standardized PLAYER_ACTION events",
      "status": "done",
      "dependencies": [
        1
      ],
      "priority": "high",
      "details": "Extend the existing ControlsManager to capture keyboard inputs ('A'/'L' keys), mouse clicks, and touch taps on PixiJS UI elements. Implement a mapping system to convert these inputs into standardized PLAYER_ACTION events. Create methods for registering interactive elements and binding actions to specific inputs. Support two distinct player actions that can be mapped to 'A'/'L' keys and on-screen buttons. Ensure the manager properly emits events through the EventBus when actions are triggered.",
      "testStrategy": "Test keyboard input detection and mapping to PLAYER_ACTION events. Verify mouse/touch input on PixiJS elements triggers correct events. Test input binding and unbinding functionality. Validate cross-device compatibility with simulated touch events."
    },
    {
      "id": 4,
      "title": "Create Reusable PixiJS UI Button Component",
      "description": "Develop a reusable Button component for PixiJS that integrates with the ControlsManager",
      "status": "done",
      "dependencies": [
        3
      ],
      "priority": "medium",
      "details": "Create a Button class in the /lib/pixi-engine/ui/ directory that extends PixiJS Container. Implement customizable appearance (background, text, hover/active states). Add support for different button states (normal, hover, pressed, disabled). Integrate with ControlsManager to emit PLAYER_ACTION events when clicked/tapped. Include accessibility features (keyboard focus, ARIA attributes). Support theming through configurable styles. Implement proper event cleanup on button destruction.",
      "testStrategy": "Test button rendering, state changes (hover, press, disable), and event emission. Verify integration with ControlsManager by confirming PLAYER_ACTION events are emitted on interaction. Test accessibility features and keyboard navigation."
    },
    {
      "id": 5,
      "title": "Enhance AssetLoader with Spritesheet Support",
      "description": "Refine the AssetLoader to handle spritesheets and establish a default asset path structure",
      "status": "done",
      "dependencies": [
        2
      ],
      "priority": "medium",
      "details": "Extend the AssetLoader to support loading and managing spritesheets. Implement methods for accessing individual sprites from loaded spritesheets. Establish a default asset path structure ('/public/images/default/') and conventions for organizing assets. Add support for different asset types (images, spritesheets, audio) with appropriate loading methods. Implement asset preloading and progress tracking. Ensure proper error handling for missing or corrupt assets.",
      "testStrategy": "Test loading various asset types (images, spritesheets, audio). Verify sprite extraction from spritesheets. Test progress tracking during asset loading. Validate error handling with missing or invalid assets."
    },
    {
      "id": 6,
      "title": "Implement Animation and Math Utilities",
      "description": "Create utility functions for animation, tweening, and common math operations",
      "status": "done",
      "dependencies": [
        5
      ],
      "priority": "medium",
      "details": "Develop a set of animation utilities in /lib/pixi-engine/utils/ including: lerp functions for smooth transitions, easing functions (ease-in, ease-out, etc.), tweening helpers for sprite animation, and common math utilities (vector operations, collision detection, etc.). Create a simple animation system that works with the PixiJS ticker. Implement chainable animation sequences. Add utilities for common sprite manipulations (fade in/out, scale, rotate).",
      "testStrategy": "Create unit tests for each utility function. Test animation sequences with different easing functions. Verify performance with multiple simultaneous animations. Test edge cases and boundary conditions for math utilities."
    },
    {
      "id": 7,
      "title": "Integrate Enhanced Components with BaseGame",
      "description": "Update the BaseGame interface and implementation to use the refined managers and utilities",
      "status": "done",
      "dependencies": [
        1,
        2,
        3,
        4,
        5,
        6
      ],
      "priority": "high",
      "details": "Update the BaseGame interface to include methods for utilizing the enhanced managers and utilities. Modify the abstract BaseGame class to properly initialize and use RuleEngine, AudioManager, ControlsManager, and animation utilities. Implement standard game lifecycle methods (init, update, destroy) that handle proper setup and teardown of all components. Create helper methods for common game operations that leverage the new utilities. Ensure proper event handling and subscription management.",
      "testStrategy": "Create a test implementation of BaseGame to verify proper initialization and usage of all managers. Test game lifecycle methods to ensure proper setup and cleanup. Validate event handling and subscription management through the game lifecycle."
    },
    {
      "id": 8,
      "title": "Update MultipleChoiceGame to Use New Components",
      "description": "Refactor the MultipleChoiceGame to leverage all the enhanced engine components",
      "status": "done",
      "dependencies": [
        7
      ],
      "priority": "high",
      "details": "Refactor the MultipleChoiceGame implementation to fully utilize the enhanced engine components. Update the game to use RuleEngine for scoring and game logic. Integrate AudioManager for sound effects on correct/incorrect answers and game events. Implement ControlsManager for handling player input through keyboard and UI buttons. Replace existing UI elements with the new PixiJS UI Button components. Utilize animation utilities for smoother transitions and feedback. Ensure the game properly follows the BaseGame interface.",
      "testStrategy": "Test the complete game flow with the new components. Verify scoring through RuleEngine works correctly. Test sound effects trigger appropriately. Validate input handling through keyboard and UI buttons. Test animations and transitions for smoothness and correctness.",
      "subtasks": [
        {
          "id": 1,
          "title": "Implement BaseGame Abstract Methods in MultipleChoiceGame",
          "description": "Update MultipleChoiceGame to properly extend BaseGame and implement all required abstract methods",
          "dependencies": [],
          "details": "1. Modify MultipleChoiceGame class to extend BaseGame\n2. Implement required abstract methods: initialize(), update(), reset(), pause(), resume()\n3. Move initialization logic from constructor to initialize() method\n4. Ensure proper cleanup in destroy() method\n5. Test each lifecycle method individually to verify correct behavior\n6. Verify game can be properly initialized, paused, resumed and reset",
          "status": "done",
          "parentTaskId": 8
        },
        {
          "id": 2,
          "title": "Refactor State Management Using BaseGame's State System",
          "description": "Replace existing state management with BaseGame's built-in state system",
          "dependencies": [
            1
          ],
          "details": "1. Identify all game states in current implementation (e.g., loading, ready, playing, gameOver)\n2. Create corresponding state constants in MultipleChoiceGame\n3. Replace direct state variable assignments with this.setState() calls\n4. Update state checking logic to use this.getState() instead of direct variable access\n5. Implement state change listeners where needed using onStateChange()\n6. Test state transitions to ensure game flow remains intact\n7. Verify all UI updates correctly respond to state changes",
          "status": "done",
          "parentTaskId": 8
        },
        {
          "id": 3,
          "title": "Integrate RuleEngine for Scoring and Game Logic",
          "description": "Replace hardcoded scoring and game rules with the RuleEngine component",
          "dependencies": [
            1,
            2
          ],
          "details": "1. Create rule definitions for scoring (correct/incorrect answers)\n2. Define rules for game progression (e.g., level advancement, game completion)\n3. Initialize RuleEngine in the initialize() method\n4. Replace direct score manipulation with RuleEngine.applyRule() calls\n5. Update game logic to use RuleEngine for determining game outcomes\n6. Add listeners for rule application events to update UI\n7. Test scoring with various answer scenarios\n8. Verify game progression rules work correctly",
          "status": "done",
          "parentTaskId": 8
        },
        {
          "id": 4,
          "title": "Implement AudioManager for Sound Effects",
          "description": "Add sound effects for game events using the AudioManager component",
          "dependencies": [
            1,
            2
          ],
          "details": "1. Initialize AudioManager in the initialize() method\n2. Define sound assets for different game events (correct answer, incorrect answer, game start, game over)\n3. Add audio triggers on appropriate game events\n4. Implement sound for correct/incorrect answers\n5. Add background music support if applicable\n6. Add volume control integration\n7. Test all sound effects trigger at appropriate times\n8. Verify sounds play correctly on different game events",
          "status": "done",
          "parentTaskId": 8
        },
        {
          "id": 5,
          "title": "Replace UI Elements with PixiJS UI Button Components",
          "description": "Update all UI elements to use the new PixiJS UI Button components",
          "dependencies": [
            1
          ],
          "details": "1. Identify all clickable UI elements in the current implementation\n2. Replace each element with the appropriate PixiJS UI Button component\n3. Configure button appearance for different states (normal, hover, pressed)\n4. Update event listeners to use the button's built-in events\n5. Ensure proper button positioning and sizing\n6. Implement button animations for feedback\n7. Test all buttons for proper interaction and visual feedback\n8. Verify accessibility features of buttons work correctly",
          "status": "done",
          "parentTaskId": 8
        },
        {
          "id": 6,
          "title": "Integrate ControlsManager for Input Handling",
          "description": "Implement ControlsManager to handle player input through keyboard and UI",
          "dependencies": [
            1,
            5
          ],
          "details": "1. Initialize ControlsManager in the initialize() method\n2. Define control mappings for keyboard inputs (e.g., number keys for answers, space for continue)\n3. Register UI button events with ControlsManager\n4. Update event handling to use ControlsManager.on() for input events\n5. Implement keyboard shortcuts for game actions\n6. Add support for alternative input methods if applicable\n7. Test keyboard and button inputs work correctly\n8. Verify input handling works consistently across different game states",
          "status": "done",
          "parentTaskId": 8
        },
        {
          "id": 7,
          "title": "Implement Animation Utilities for Transitions and Feedback",
          "description": "Add smooth animations for game transitions and player feedback",
          "dependencies": [
            1,
            2,
            5
          ],
          "details": "1. Identify opportunities for animations (question transitions, feedback, score updates)\n2. Implement animations for correct/incorrect answer feedback\n3. Add transitions between questions using animation utilities\n4. Create animations for game state changes (start, end)\n5. Implement score change animations\n6. Ensure animations are properly cleaned up when not needed\n7. Test all animations for smoothness and timing\n8. Verify animations enhance rather than hinder gameplay",
          "status": "done",
          "parentTaskId": 8
        }
      ]
    },
    {
      "id": 9,
      "title": "Implement AI Quiz Generation Service",
      "description": "Create a service to generate quiz content using AI (Gemini API or similar)",
      "status": "pending",
      "dependencies": [
        8
      ],
      "priority": "low",
      "details": "Develop an AI service integration in the backend to generate quiz content. Set up connection to Gemini API (or chosen provider) with proper authentication and error handling. Create a structured prompt template that guides the AI to generate well-formatted quiz questions and answers. Implement parsing logic to convert AI responses into the application's quiz data structure. Add rate limiting and caching to manage API usage. Create a backend endpoint that accepts generation parameters (topic, level, etc.) and returns formatted quiz content.",
      "testStrategy": "Test API integration with various input parameters. Verify parsing logic correctly extracts questions and answers. Test error handling with API failures. Validate quality of generated content across different topics and difficulty levels."
    },
    {
      "id": 10,
      "title": "Create Quiz Form AI Input UI",
      "description": "Enhance the Quiz Creation form with AI generation capabilities",
      "status": "pending",
      "dependencies": [
        9
      ],
      "priority": "low",
      "details": "Update the Quiz Creation form to include AI generation fields. Add input fields for topic, educational level, number of questions, and optional examples. Implement a 'Generate with AI' button that calls the AI service endpoint. Create a loading state for the generation process. Implement logic to populate the form with AI-generated content while allowing teacher editing. Add error handling and feedback for failed generation attempts. Include a preview mode to review generated content before saving.",
      "testStrategy": "Test the UI flow from input parameters to generated content. Verify form population with AI-generated content. Test editing capabilities after generation. Validate error handling and user feedback. Test across different browsers and device sizes."
    },
    {
      "id": 11,
      "title": "Implement Hybrid Scaling System with Logical Resolution Profiles in PixiJS",
      "description": "Refactor the current PixiJS scaling/resizing logic to use a hybrid approach with predefined logical resolution profiles, applying a single scaleFactor to maintain aspect ratio while positioning UI elements using logical coordinates.",
      "details": "This task involves replacing the current granular layout profile system with a more efficient hybrid scaling approach:\n\n1. Modify the LayoutManager to define 2-3 core logical resolutions (e.g., 16:9, 4:3, 21:9) as profiles.\n2. Implement a mechanism to select the best-matching logical profile when the window is resized.\n3. Calculate a single scaleFactor that fits the selected logical resolution within the window while preserving the aspect ratio.\n4. Apply this scaleFactor to app.stage.scale instead of recalculating individual element properties.\n5. Update the canvas CSS display size to match the scaled dimensions.\n6. Add logic to center the canvas in the window.\n7. Refactor UIManager to position UI elements using logical coordinates from the selected profile.\n8. Implement relative sizing parameters in the profiles that UI elements can reference.\n9. Remove all code related to the current system of recalculating individual element properties based on multiple granular layout profiles.\n10. Ensure smooth transitions between different logical resolutions when the window is resized.\n11. Add appropriate documentation for the new scaling system.\n\nThe goal is to simplify the scaling logic while maintaining visual consistency across different screen sizes and aspect ratios.",
      "testStrategy": "Testing should verify the new scaling system works correctly across various scenarios:\n\n1. Unit tests:\n   - Test profile selection logic with various window dimensions\n   - Verify scaleFactor calculation for different logical resolutions\n   - Test canvas centering calculations\n\n2. Integration tests:\n   - Verify UI elements position correctly using the logical coordinates\n   - Test transitions between different logical resolutions\n\n3. Visual regression tests:\n   - Compare screenshots before and after implementation at various resolutions\n   - Verify UI elements maintain proper proportions and positions\n\n4. Manual testing:\n   - Test on multiple devices with different aspect ratios (16:9, 4:3, 21:9)\n   - Verify performance during window resizing (should be smoother than previous implementation)\n   - Test extreme cases (very small windows, very large windows, unusual aspect ratios)\n   - Verify that all UI elements remain accessible and functional at all supported resolutions\n\n5. Browser compatibility:\n   - Test across Chrome, Firefox, Safari, and Edge\n   - Verify mobile browser compatibility\n\nDocument any visual differences from the previous implementation and get stakeholder approval if the layout changes significantly.",
      "status": "pending",
      "dependencies": [
        8
      ],
      "priority": "medium"
    },
    {
      "id": 12,
      "title": "Implement Zustand Store for Game Managers with React Integration",
      "description": "Create a Zustand store to manage game manager instances and integrate it with the React component lifecycle, ensuring proper initialization and cleanup of manager resources.",
      "details": "This task focuses on implementing the `useManagersStore.ts` Zustand store which will serve as the central access point for all game manager instances:\n\n1. Create `src/lib/stores/useManagersStore.ts` with the following structure:\n   - Define a `ManagersState` interface that includes properties for all core managers (e.g., `eventBus`, `assetManager`, `soundManager`) and game-specific managers (e.g., `questionManager`, `teamManager`)\n   - Implement the store using Zustand's create function with methods for:\n     - `setManager(key, instance)`: Add or update a manager instance\n     - `getManager(key)`: Retrieve a specific manager\n     - `clearManagers()`: Reset all managers (for cleanup)\n\n2. Update the initialization flow in `GameplayView.tsx`:\n   - Import the new store\n   - In a useEffect with empty dependency array, initialize the PixiEngine\n   - Store all manager instances in the Zustand store as they're created\n   - Return a cleanup function that calls `clearManagers()` and properly destroys the engine\n\n3. Create a custom hook `useGameManager<T>(managerKey)` that:\n   - Returns a typed manager instance from the store\n   - Throws a helpful error if the requested manager isn't available\n   - Includes TypeScript generics for type safety\n\n4. Add middleware to the store that logs manager creation and access in development mode\n\n5. Document the manager lifecycle and access patterns in comments at the top of the store file\n\n6. Ensure the store is properly integrated with React's component lifecycle to prevent memory leaks",
      "testStrategy": "1. Unit Tests:\n   - Test store initialization with empty state\n   - Verify `setManager` correctly adds a new manager instance\n   - Verify `getManager` retrieves the correct manager\n   - Confirm `clearManagers` properly resets the store\n   - Test error handling when requesting non-existent managers\n\n2. Integration Tests:\n   - Create a test component that initializes the engine and managers\n   - Verify all expected managers are available in the store after initialization\n   - Test component unmounting to ensure proper cleanup occurs\n   - Verify no memory leaks by checking that all managers are properly destroyed\n\n3. Manual Testing:\n   - In the browser, initialize the game and use React DevTools to inspect the Zustand store\n   - Verify managers are accessible from different components\n   - Test a full game session and confirm no console errors related to managers\n   - Check memory usage in Chrome DevTools to ensure no memory leaks after multiple game sessions\n   - Verify that navigating away from the game view properly cleans up all resources",
      "status": "pending",
      "dependencies": [
        8
      ],
      "priority": "high"
    },
    {
      "id": 13,
      "title": "Execute PixiEngine Refactor for @pixi/react and Zustand Integration",
      "description": "Implement a comprehensive, phased refactoring plan to integrate @pixi/react for rendering and Zustand for global state management, replacing the current imperative PixiJS implementation.",
      "details": "This task covers the entire refactoring effort described in scripts/refactor_prd.md, divided into four phases:\n\nPhase 1 (Setup & Background):\n- Install and configure @pixi/react and Zustand dependencies\n- Create initial Zustand store structure for game state\n- Set up project architecture for component-based rendering\n- Establish patterns for React component lifecycle integration with game logic\n\nPhase 2 (Timer & Game Logic Refinement):\n- Refactor timer functionality to use Zustand for state management\n- Convert game logic to work with the reactive state model\n- Implement hooks for accessing game state and dispatching actions\n- Ensure game loop and timing mechanisms work correctly with React's rendering cycle\n\nPhase 3 (Core Question Scene):\n- Refactor the main question scene using @pixi/react components\n- Convert all visual elements to declarative React components\n- Implement state-driven animations and transitions\n- Ensure interaction handlers work properly with the new component structure\n\nPhase 4 (Final Integration & Cleanup):\n- Complete migration of all remaining game scenes and components\n- Refine global state architecture and optimize performance\n- Remove legacy imperative code and cleanup technical debt\n- Document the new architecture and component patterns\n\nThis architectural change is critical for future app development, providing a more maintainable and declarative approach to game development.",
      "testStrategy": "Testing will be conducted at each phase with the following approach:\n\nPhase 1:\n- Verify correct installation and configuration of dependencies\n- Test basic Zustand store operations with Jest unit tests\n- Confirm React component rendering of simple PixiJS elements\n- Validate project structure meets architectural requirements\n\nPhase 2:\n- Test timer accuracy and consistency under various conditions\n- Verify game state transitions work correctly through the Zustand store\n- Conduct performance testing to ensure no degradation from the refactor\n- Create integration tests for game logic with the new state management\n\nPhase 3:\n- Perform visual regression testing on the question scene\n- Test all user interactions and verify correct behavior\n- Validate animations and transitions match original implementation\n- Test across different screen sizes and device capabilities\n\nPhase 4:\n- Conduct end-to-end testing of the complete game flow\n- Verify all features function identically to pre-refactor version\n- Performance profiling to identify and address any bottlenecks\n- Cross-browser testing to ensure compatibility\n\nOverall success criteria: All existing game functionality is preserved or enhanced, developer experience is improved with more intuitive state management and component structure, and the codebase is more maintainable for future development.",
      "status": "pending",
      "dependencies": [],
      "priority": "high",
      "subtasks": [
        {
          "id": 1,
          "title": "Phase 1: Setup Zustand, Bridge Engine to React, Convert Background",
          "description": "Establish the @pixi/react rendering environment, create foundational Zustand stores for global access to configuration and managers, and convert the simplest visual piece (GameBackground) to validate the setup. This phase focuses on reading data from Zustand.",
          "details": "Steps:\n1. Dependencies: Install pixi.js, @pixi/react, zustand.\n2. @pixi/react Setup in GameplayView.tsx: Import and render <Application /> from @pixi/react inside the pixiMountPointRef div. Pass necessary props (width, height, etc.). Call extend (from @pixi/react) for common PIXI classes.\n3. PixiEngine Adaptation: Modify PixiEngine.init to not create its own PixiApplication. Ensure destroy still cleans up managers.\n4. Zustand Stores (Foundation): Create useGameConfigStore (holds GameConfig), useManagersStore (holds manager instances), useGameDisplayStateStore (reflecting store with EventBus listeners for PHASE_CHANGED, ACTIVE_TEAM_CHANGED, SCORE_UPDATED).\n5. GameplayView.tsx Adaptation: Use useEffect for PixiEngine init and Zustand population. Source overlay state from useGameDisplayStateStore.\n6. Refactor Background: Create GameBackground.tsx. Use stores for data/theme. Use <pixiSprite> or <pixiGraphics>. Render inside <Application />. Remove GameBackgroundManager.ts.\n7. Address \"State in Two Places\": Explicitly acknowledge that managers remain the source of truth; Zustand stores reflect this state for UI consumption via events.",
          "status": "pending",
          "dependencies": [],
          "parentTaskId": 13
        },
        {
          "id": 2,
          "title": "Phase 2: Convert Timer Display and Refine MultipleChoiceGame Logic",
          "description": "Convert another UI element (TimerDisplay) to React-Pixi, ensuring it reacts to state changes originating from a core manager (TimerManager) via Zustand. Begin simplifying the MultipleChoiceGame by removing its direct UI update responsibilities.",
          "details": "Steps:\n1. Refactor Timer Display: Create TimerDisplay.tsx. Use <pixiGraphics />/<pixiText />. Add currentTimeRemaining, initialDuration to useGameDisplayStateStore (listens to TIMER_EVENTS.TIMER_TICK). TimerDisplay subscribes to store and gets layout from LayoutManager (via useManagersStore). Render inside <Application />. Remove timer rendering from MultipleChoiceUIManager/QuestionScene. MultipleChoiceGame still uses TimerManager for logic.\n2. Refine MultipleChoiceGame.ts: Review _handleTimerComplete, _processAnswerSelection. Remove direct UI calls. Focus on game logic, state changes, events. Keep transition logic for now.",
          "status": "pending",
          "dependencies": [],
          "parentTaskId": 13
        },
        {
          "id": 3,
          "title": "Phase 3: Tackle the Core Question Scene and Answer Interaction",
          "description": "Replace the most complex part of the imperative rendering (QuestionScene, MultipleChoiceUIManager) with a hierarchy of React-Pixi components driven by a dedicated Zustand store for the current question state. Handle user interaction (answer selection) via Zustand actions.",
          "details": "Steps:\n1. Create React-Pixi Scene Components: Build QuestionText.tsx, QuestionMedia.tsx, AnswerButton.tsx, AnswerOptionsPanel.tsx, and CurrentQuestionDisplayScene.tsx. Get data/theme/layout via Zustand hooks.\n2. Create useCurrentQuestionStore: State (currentQuestionData, currentAnswerOptions, isAnswerSubmitted). Action (fetchAndSetQuestion: accesses multipleChoiceDataManager, gets next question, handles 50/50 power-up, updates store). Action (submitAnswer: sets isAnswerSubmitted, emits GAME_EVENTS.ANSWER_SELECTED via eventBus).\n3. Trigger Question Updates: Modify MultipleChoiceGame._showQuestion to trigger fetchAndSetQuestion action (e.g., via NEW_QUESTION_READY event).\n4. Integrate Scene Component: Render <CurrentQuestionDisplayScene /> inside <Application />. It subscribes to useCurrentQuestionStore. AnswerButton onClick calls store's submitAnswer.\n5. Deprecate/Remove Old Managers: Remove MultipleChoiceUIManager.ts and QuestionScene.ts.",
          "status": "pending",
          "dependencies": [],
          "parentTaskId": 13
        },
        {
          "id": 4,
          "title": "Phase 4: Final Integration & Cleanup",
          "description": "Ensure all remaining React UI overlays use Zustand, finalize the slimming down of MultipleChoiceGame, and review the overall architecture.",
          "details": "Steps:\n1. Connect UI Overlays: Ensure PlayerScore.tsx, NavMenu.tsx, GameControlDropdown.tsx read state from and write changes via Zustand stores/actions (e.g., audio settings changes trigger Zustand actions -> emit SETTINGS_EVENTS).\n2. Finalize MultipleChoiceGame.ts: Remove any residual rendering logic. Confirm its focus is on data/sequence management, handling core logic events, and phase orchestration.\n3. Review BaseGame.ts & PixiEngine.ts: Ensure abstractions are clean and roles align with the new architecture (bootstrapping, manager hosting).",
          "status": "pending",
          "dependencies": [],
          "parentTaskId": 13
        }
      ]
    }
  ],
  "metadata": {
    "projectName": "PRD Implementation",
    "totalTasks": 10,
    "sourceFile": "C:\\Users\\LENOVO\\Documents\\PROGRAMMING\\projects\\atoz_pixi\\scripts\\prd.txt",
    "generatedAt": "2024-06-24"
  }
}